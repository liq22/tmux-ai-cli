#!/usr/bin/env bash
# ai - AI tmux session 简短管理命令 v0.0.1
# 单文件实现：交互命令 + `--json` 契约（供 VS Code 扩展）

set -euo pipefail

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 配置文件路径：优先使用 ~/.config/tmux-ai/，否则使用相对于脚本的路径
CONFIG_DIR="${TMUX_AI_CONFIG:-$HOME/.config/tmux-ai}"
if [ -d "$CONFIG_DIR" ]; then
  tmux_conf="$CONFIG_DIR/.tmux.conf"
  types_yaml="$CONFIG_DIR/ai-types.yaml"
else
  tmux_conf="$script_dir/../config/.tmux.conf"
  types_yaml="$script_dir/../config/ai-types.yaml"
fi

TMUX_SOCKET="${TMUX_AI_SOCKET:-ai}"
SESSION_PREFIX="ai"
MASTER_SESSION="${SESSION_PREFIX}-master"
PROTOCOL_VERSION=1
TMUX_AI_TYPE_OPTION="@tmux_ai_type"

log_debug() {
  if [ "${TMUX_AI_DEBUG:-0}" != "0" ]; then
    printf '[tmux-ai-cli] %s\n' "$*" >&2
  fi
}

expand_path() {
  local p="${1:-}"
  if [ -z "$p" ]; then
    return 0
  fi
  if [ "$p" = "~" ]; then
    printf '%s\n' "$HOME"
    return 0
  fi
  if [[ "$p" == "~/"* ]]; then
    printf '%s\n' "$HOME/${p#~/}"
    return 0
  fi
  if [[ "$p" != /* ]]; then
    printf '%s\n' "$(pwd)/$p"
    return 0
  fi
  printf '%s\n' "$p"
}

count_backend_sessions() {
  local base="${1:-}"
  local socket="${2:-}"
  local raw filtered

  if [ -n "$base" ]; then
    raw="$(TMUX_TMPDIR="$base" tmux -L "$socket" list-sessions -F '#{session_name}' 2>/dev/null || true)"
  else
    raw="$(tmux -L "$socket" list-sessions -F '#{session_name}' 2>/dev/null || true)"
  fi

  filtered="$(printf '%s\n' "$raw" | grep -E "^${SESSION_PREFIX}-" | grep -v "^${MASTER_SESSION}$" | sort || true)"
  if [ -z "$filtered" ]; then
    printf '0\n'
    return 0
  fi
  printf '%s\n' "$filtered" | sed '/^$/d' | wc -l | tr -d ' '
}

list_backend_sessions() {
  local base="${1:-}"
  local socket="${2:-}"
  local raw

  if [ -n "$base" ]; then
    raw="$(TMUX_TMPDIR="$base" tmux -L "$socket" list-sessions -F '#{session_name}' 2>/dev/null || true)"
  else
    raw="$(tmux -L "$socket" list-sessions -F '#{session_name}' 2>/dev/null || true)"
  fi

  printf '%s\n' "$raw" | grep -E "^${SESSION_PREFIX}-" | grep -v "^${MASTER_SESSION}$" | sort || true
}

has_backend_master() {
  local base="${1:-}"
  local socket="${2:-}"
  if [ -n "$base" ]; then
    TMUX_TMPDIR="$base" tmux -L "$socket" has-session -t "$MASTER_SESSION" 2>/dev/null
    return $?
  fi
  tmux -L "$socket" has-session -t "$MASTER_SESSION" 2>/dev/null
}

socket_rank() {
  case "${1:-}" in
    ai) printf '2\n' ;;
    default) printf '1\n' ;;
    *) printf '0\n' ;;
  esac
}

is_subset_sessions() {
  local small="${1:-}"
  local big="${2:-}"
  [ -z "$small" ] && return 0
  declare -A big_set=()
  while read -r s; do
    [ -z "$s" ] && continue
    big_set["$s"]=1
  done <<<"$big"
  while read -r s; do
    [ -z "$s" ] && continue
    if [ -z "${big_set[$s]+x}" ]; then
      return 1
    fi
  done <<<"$small"
  return 0
}

detect_tmux_backend() {
  local socket_fixed=0
  local tmp_fixed=0
  [ -n "${TMUX_AI_SOCKET:-}" ] && socket_fixed=1
  [ -n "${TMUX_TMPDIR:-}" ] && tmp_fixed=1

  local uid=""
  uid="$(id -u 2>/dev/null || true)"
  if [ -z "$uid" ]; then
    return 0
  fi

  local current_base="${TMUX_TMPDIR:-}"
  local current_socket="${TMUX_AI_SOCKET:-ai}"
  local current_sessions current_count
  current_sessions="$(list_backend_sessions "$current_base" "$current_socket")"
  current_count="$(count_backend_sessions "$current_base" "$current_socket")"

  local -a bases=()
  declare -A seen=()
  add_base() {
    local b="${1:-}"
    [ -z "$b" ] && return 0
    b="$(expand_path "$b")"
    b="${b%/}"
    [ -z "$b" ] && return 0
    if [ -n "${seen[$b]+x}" ]; then
      return 0
    fi
    seen["$b"]=1
    bases+=("$b")
    return 0
  }

  if [ "$tmp_fixed" -eq 1 ]; then
    add_base "${TMUX_TMPDIR}"
  else
    add_base "${TMPDIR:-}"
    add_base "${TMP:-}"
    add_base "${TEMP:-}"
    add_base "${XDG_RUNTIME_DIR:-}"
    add_base "$HOME/.tmux-tmp"
    add_base "$PWD/.tmux-tmp"
    add_base "/tmp"
    add_base "/var/tmp"
  fi

  local best_base="" best_socket="" best_count=0 best_master=0 best_rank=0 best_sessions=""
  local best_superset_base="" best_superset_socket="" best_superset_count=0 best_superset_master=0 best_superset_rank=0 best_superset_sessions=""

  is_better_candidate() {
    local count="$1" master="$2" rank="$3"
    local best_count_="$4" best_master_="$5" best_rank_="$6"
    if [ "$count" -gt "$best_count_" ]; then
      return 0
    fi
    if [ "$count" -lt "$best_count_" ]; then
      return 1
    fi
    if [ "$master" -gt "$best_master_" ]; then
      return 0
    fi
    if [ "$master" -lt "$best_master_" ]; then
      return 1
    fi
    if [ "$rank" -gt "$best_rank_" ]; then
      return 0
    fi
    return 1
  }

  for base in "${bases[@]}"; do
    local socket_dir="$base/tmux-$uid"
    [ -d "$socket_dir" ] || continue

    if [ "$socket_fixed" -eq 1 ]; then
      local sock="$current_socket"
      [ -S "$socket_dir/$sock" ] || continue

      local count master rank sessions
      count="$(count_backend_sessions "$base" "$sock")"
      sessions="$(list_backend_sessions "$base" "$sock")"
      master=0
      if has_backend_master "$base" "$sock"; then
        master=1
      fi
      rank="$(socket_rank "$sock")"

      if is_better_candidate "$count" "$master" "$rank" "$best_count" "$best_master" "$best_rank"; then
        best_base="$base"
        best_socket="$sock"
        best_count="$count"
        best_master="$master"
        best_rank="$rank"
        best_sessions="$sessions"
      fi

      if [ "$current_count" -gt 0 ] && is_subset_sessions "$current_sessions" "$sessions"; then
        if is_better_candidate "$count" "$master" "$rank" "$best_superset_count" "$best_superset_master" "$best_superset_rank"; then
          best_superset_base="$base"
          best_superset_socket="$sock"
          best_superset_count="$count"
          best_superset_master="$master"
          best_superset_rank="$rank"
          best_superset_sessions="$sessions"
        fi
      fi
      continue
    fi

    for sock_path in "$socket_dir"/*; do
      [ -S "$sock_path" ] || continue
      local sock="${sock_path##*/}"

      local count master rank sessions
      count="$(count_backend_sessions "$base" "$sock")"
      if [ "$count" -eq 0 ]; then
        continue
      fi
      sessions="$(list_backend_sessions "$base" "$sock")"
      master=0
      if has_backend_master "$base" "$sock"; then
        master=1
      fi
      rank="$(socket_rank "$sock")"

      if is_better_candidate "$count" "$master" "$rank" "$best_count" "$best_master" "$best_rank"; then
        best_base="$base"
        best_socket="$sock"
        best_count="$count"
        best_master="$master"
        best_rank="$rank"
        best_sessions="$sessions"
      fi

      if [ "$current_count" -gt 0 ] && is_subset_sessions "$current_sessions" "$sessions"; then
        if is_better_candidate "$count" "$master" "$rank" "$best_superset_count" "$best_superset_master" "$best_superset_rank"; then
          best_superset_base="$base"
          best_superset_socket="$sock"
          best_superset_count="$count"
          best_superset_master="$master"
          best_superset_rank="$rank"
          best_superset_sessions="$sessions"
        fi
      fi
    done
  done

  local should_switch=0
  local chosen_socket="" chosen_base=""
  if [ "$current_count" -eq 0 ]; then
    if [ -z "$best_socket" ] || [ "$best_count" -eq 0 ]; then
      return 0
    fi
    should_switch=1
    chosen_socket="$best_socket"
    chosen_base="$best_base"
  else
    if [ -z "$best_superset_socket" ] || [ "$best_superset_count" -eq 0 ]; then
      return 0
    fi
    if [ "$best_superset_count" -gt "$current_count" ]; then
      should_switch=1
    elif [ "$best_superset_base" != "$current_base" ] || [ "$best_superset_socket" != "$current_socket" ]; then
      should_switch=1
    fi
    chosen_socket="$best_superset_socket"
    chosen_base="$best_superset_base"
  fi

  if [ "$should_switch" -eq 1 ]; then
    if [ "$socket_fixed" -eq 0 ]; then
      TMUX_SOCKET="$chosen_socket"
    fi
    if [ "$tmp_fixed" -eq 0 ]; then
      export TMUX_TMPDIR="$chosen_base"
    fi
    log_debug "auto-detected tmux backend: socket=${TMUX_SOCKET}; TMUX_TMPDIR=${TMUX_TMPDIR:-<unset>}"
  else
    if [ "${TMUX_AI_DEBUG:-0}" != "0" ] && [ "$best_count" -gt "$current_count" ]; then
      log_debug "found another backend with more sessions: socket=$best_socket TMUX_TMPDIR=$best_base (count=$best_count). Set TMUX_AI_SOCKET/TMUX_TMPDIR to switch."
    fi
  fi
}

detect_tmux_backend

if [ -n "${TMUX_TMPDIR:-}" ]; then
  TMUX_CMD=(env TMUX_TMPDIR="$TMUX_TMPDIR" tmux -f "$tmux_conf" -L "$TMUX_SOCKET")
else
  TMUX_CMD=(tmux -f "$tmux_conf" -L "$TMUX_SOCKET")
fi

has_python3() {
  command -v python3 >/dev/null 2>&1
}

json_escape_bash() {
  local s="${1-}"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  s="${s//$'\n'/\\n}"
  s="${s//$'\r'/\\r}"
  s="${s//$'\t'/\\t}"
  printf '%s' "$s"
}

json_print_obj() {
  if has_python3; then
    python3 - "$PROTOCOL_VERSION" "$@" <<'PY'
import json, sys

protocol_version = int(sys.argv[1])
payload = json.loads(sys.argv[2])
payload.setdefault("protocolVersion", protocol_version)
print(json.dumps(payload, ensure_ascii=False))
PY
    return
  fi

  printf '%s\n' "$1"
}

json_error() {
  local code="$1"
  local message="$2"
  local hint="${3:-}"

  if has_python3; then
    python3 - "$PROTOCOL_VERSION" "$code" "$message" "$hint" <<'PY'
import json, sys

protocol_version = int(sys.argv[1])
code = sys.argv[2]
message = sys.argv[3]
hint = sys.argv[4]

obj = {"ok": False, "protocolVersion": protocol_version, "code": code, "message": message}
if hint:
  obj["hint"] = hint
print(json.dumps(obj, ensure_ascii=False))
PY
    return 1
  fi

  local msg_esc hint_esc
  msg_esc="$(json_escape_bash "$message")"
  hint_esc="$(json_escape_bash "$hint")"

  if [ -n "$hint" ]; then
    printf '{"ok":false,"protocolVersion":%d,"code":"%s","message":"%s","hint":"%s"}\n' \
      "$PROTOCOL_VERSION" "$code" "$msg_esc" "$hint_esc"
  else
    printf '{"ok":false,"protocolVersion":%d,"code":"%s","message":"%s"}\n' \
      "$PROTOCOL_VERSION" "$code" "$msg_esc"
  fi
  return 1
}

json_ok_simple() {
  printf '{"ok":true,"protocolVersion":%d}\n' "$PROTOCOL_VERSION"
}

iso_now() {
  # 尽量输出 ISO8601（UTC）。
  if date -u +"%Y-%m-%dT%H:%M:%SZ" >/dev/null 2>&1; then
    date -u +"%Y-%m-%dT%H:%M:%SZ"
    return
  fi
  date
}

epoch_to_iso_fallback() {
  local epoch="${1:-}"
  if [ -z "$epoch" ] || [ "$epoch" = "0" ]; then
    printf ''
    return
  fi
  if date -u -d "@$epoch" +"%Y-%m-%dT%H:%M:%SZ" >/dev/null 2>&1; then
    date -u -d "@$epoch" +"%Y-%m-%dT%H:%M:%SZ"
    return
  fi
  if date -u -r "$epoch" +"%Y-%m-%dT%H:%M:%SZ" >/dev/null 2>&1; then
    date -u -r "$epoch" +"%Y-%m-%dT%H:%M:%SZ"
    return
  fi
  printf ''
}

is_valid_short_name() {
  local name="${1:-}"
  [[ "$name" =~ ^[A-Za-z0-9_-]+$ ]]
}

# 快捷别名映射
# c1 → claude-1, g2 → gemini-2, x1 → codex-1
expand_shortcut() {
  local input="$1"
  case "$input" in
    c[0-9]*) echo "claude-${input#c}" ;;
    g[0-9]*) echo "gemini-${input#g}" ;;
    x[0-9]*) echo "codex-${input#x}" ;;
    *) echo "$input" ;;
  esac
}

is_valid_session_name() {
  local name="$1"
  [[ "$name" =~ ^${SESSION_PREFIX}-[A-Za-z0-9_-]+$ ]]
}

# 获取所有实例 sessions（排除 master）
get_instance_sessions() {
  "${TMUX_CMD[@]}" list-sessions -F '#{session_name}' 2>/dev/null | \
    grep -E "^${SESSION_PREFIX}-" | \
    grep -v "^${MASTER_SESSION}$" | \
    sort || true
}

tmux_session_from_short_name() {
  printf '%s-%s' "$SESSION_PREFIX" "$1"
}

tmux_session_type() {
  local session="$1"
  local v
  v="$("${TMUX_CMD[@]}" show-options -q -v -t "$session" "$TMUX_AI_TYPE_OPTION" 2>/dev/null || true)"
  if [ -n "$v" ]; then
    printf '%s' "$v"
    return
  fi

  # 兼容旧 session：从 shortName（如 claude-1）推导 type
  local short_name="${session#${SESSION_PREFIX}-}"
  if [[ "$short_name" =~ ^([A-Za-z0-9_-]+)-[0-9]+$ ]]; then
    printf '%s' "${BASH_REMATCH[1]}"
    return
  fi

  printf ''
}

get_cmd_for_type() {
  local type="$1"
  awk -v type="$type" '
    BEGIN { in_types = 0; in_type = 0 }
    /^[[:space:]]*types:[[:space:]]*$/ { in_types = 1; next }
    !in_types { next }
    $0 ~ "^  " type ":[[:space:]]*$" { in_type = 1; next }
    in_type {
      if ($0 ~ "^  [A-Za-z0-9_-]+:[[:space:]]*$") { exit }
      if ($0 ~ "^[[:space:]]*cmd:[[:space:]]*") {
        sub("^[[:space:]]*cmd:[[:space:]]*", "", $0)
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", $0)
        if ($0 ~ /^\".*\"$/) { sub(/^\"/, "", $0); sub(/\"$/, "", $0) }
        if ($0 ~ /^'\''.*'\''$/) { sub(/^'\''/, "", $0); sub(/'\''$/, "", $0) }
        print $0
        exit
      }
    }
  ' "$types_yaml"
}

emit_types_lines() {
  awk '
    BEGIN { in_types=0; current=""; icon=""; base_color=""; desc=""; label="" }
    function flush() {
      if (current == "") return
      printf "T\t%s\t%s\t%s\t%s\t%s\n", current, label, icon, base_color, desc
    }
    /^[[:space:]]*types:[[:space:]]*$/ { in_types=1; next }
    !in_types { next }
    /^[A-Za-z0-9_-]+:[[:space:]]*$/ { flush(); current=""; exit }
    /^  [A-Za-z0-9_-]+:[[:space:]]*$/ {
      flush()
      current=$0
      sub(/^[[:space:]]+/, "", current)
      sub(/:[[:space:]]*$/, "", current)
      icon=""; base_color=""; desc=""; label=""
      next
    }
    current != "" {
      if ($1 == "icon:" ) { icon=$2; next }
      if ($1 == "base_color:" ) { base_color=$2; next }
      if ($1 == "label:" ) {
        sub(/^[[:space:]]*label:[[:space:]]*/, "", $0)
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", $0)
        gsub(/^"|"$/, "", $0)
        gsub(/^'\''|'\''$/, "", $0)
        label=$0
        next
      }
      if ($1 == "description:" ) {
        sub(/^[[:space:]]*description:[[:space:]]*/, "", $0)
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", $0)
        gsub(/^"|"$/, "", $0)
        gsub(/^'\''|'\''$/, "", $0)
        desc=$0
        next
      }
    }
    END { flush() }
  ' "$types_yaml"
}

emit_sessions_lines() {
  local sessions
  sessions="$(get_instance_sessions)"
  if [ -z "$sessions" ]; then
    return
  fi

  while read -r session; do
    [ -z "$session" ] && continue
    local short_name="${session#${SESSION_PREFIX}-}"
    local type
    type="$(tmux_session_type "$session")"
    local attached_clients created_epoch last_used_epoch window_name
    attached_clients="$("${TMUX_CMD[@]}" list-clients -t "$session" 2>/dev/null | wc -l | tr -d ' ')"
    read -r _sess created_epoch last_used_epoch < <("${TMUX_CMD[@]}" list-sessions -t "$session" -F '#{session_name} #{session_created} #{session_activity}' 2>/dev/null || true)
    window_name="$("${TMUX_CMD[@]}" list-windows -t "$session" -F '#{window_name}' 2>/dev/null | head -1 || true)"
    printf 'S\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' \
      "$session" "$short_name" "$type" "$attached_clients" "$created_epoch" "$last_used_epoch" "$window_name"
  done <<<"$sessions"
}

cmd_list_json() {
  if [ ! -f "$types_yaml" ]; then
    json_error "E_CONFIG_NOT_FOUND" "types 配置不存在" "未找到: $types_yaml"
    return 1
  fi

  if has_python3; then
    { emit_types_lines; emit_sessions_lines; } | python3 -c '
import json, sys
from datetime import datetime, timezone

protocol_version = int(sys.argv[1])
now_iso = sys.argv[2]

types = {}
sessions = []

def to_iso(epoch_str: str) -> str:
  try:
    epoch = int(epoch_str)
  except Exception:
    return ""
  if epoch <= 0:
    return ""
  return datetime.fromtimestamp(epoch, tz=timezone.utc).isoformat().replace("+00:00", "Z")

for raw in sys.stdin:
  raw = raw.rstrip("\n")
  if not raw:
    continue
  parts = raw.split("\t")
  kind = parts[0]
  if kind == "T":
    _, type_id, label, icon, base_color, desc = (parts + ["", "", "", "", ""])[:6]
    if not label:
      label = type_id[:1].upper() + type_id[1:]
    types[type_id] = {"label": label, "icon": icon, "base_color": base_color, "desc": desc}
  elif kind == "S":
    _, name, short_name, type_id, attached, created_epoch, last_used_epoch, window_name = (parts + [""] * 8)[:8]
    attached_int = 0
    try:
      attached_int = int(attached)
    except Exception:
      attached_int = 0
    sessions.append({
      "name": name,
      "shortName": short_name,
      "type": type_id,
      "tmuxSession": name,
      "attachedClients": attached_int,
      "created": to_iso(created_epoch),
      "lastUsed": to_iso(last_used_epoch),
      "windowName": window_name,
    })

obj = {"ok": True, "protocolVersion": protocol_version, "types": types, "sessions": sessions, "now": now_iso}
print(json.dumps(obj, ensure_ascii=False))
' "$PROTOCOL_VERSION" "$(iso_now)"
    return 0
  fi

  # fallback：纯 bash 组装 JSON
  local now
  now="$(iso_now)"
  printf '{"ok":true,"protocolVersion":%d,"types":{' "$PROTOCOL_VERSION"

  local first_type="1"
  while IFS=$'\t' read -r _kind type_id label icon base_color desc; do
    [ -z "$type_id" ] && continue
    if [ "$first_type" = "0" ]; then
      printf ','
    fi
    first_type="0"
    if [ -z "$label" ]; then
      label="${type_id^}"
    fi
    printf '"%s":{"label":"%s","icon":"%s","base_color":"%s","desc":"%s"}' \
      "$(json_escape_bash "$type_id")" \
      "$(json_escape_bash "$label")" \
      "$(json_escape_bash "$icon")" \
      "$(json_escape_bash "$base_color")" \
      "$(json_escape_bash "$desc")"
  done < <(emit_types_lines || true)

  printf '},"sessions":['
  local first_sess="1"
  while IFS=$'\t' read -r _kind name short_name type_id attached created_epoch last_used_epoch window_name; do
    [ -z "$name" ] && continue
    if [ "$first_sess" = "0" ]; then
      printf ','
    fi
    first_sess="0"
    printf '{"name":"%s","shortName":"%s","type":"%s","tmuxSession":"%s","attachedClients":%s,"created":"%s","lastUsed":"%s","windowName":"%s"}' \
      "$(json_escape_bash "$name")" \
      "$(json_escape_bash "$short_name")" \
      "$(json_escape_bash "$type_id")" \
      "$(json_escape_bash "$name")" \
      "${attached:-0}" \
      "$(json_escape_bash "$(epoch_to_iso_fallback "$created_epoch")")" \
      "$(json_escape_bash "$(epoch_to_iso_fallback "$last_used_epoch")")" \
      "$(json_escape_bash "$window_name")"
  done < <(emit_sessions_lines || true)
  printf '],"now":"%s"}\n' "$(json_escape_bash "$now")"
}

tmux_new_session_atomic() {
  local type="$1"
  local cmd="$2"
  local desired_short_name="${3:-}"

  if [ -n "$desired_short_name" ]; then
    local short_name="$desired_short_name"
    local session_name
    session_name="$(tmux_session_from_short_name "$short_name")"
    if "${TMUX_CMD[@]}" has-session -t "$session_name" 2>/dev/null; then
      return 3
    fi
    local err
    err="$("${TMUX_CMD[@]}" new-session -d -s "$session_name" -n "$short_name" "$cmd" 2>&1)" || {
      if echo "$err" | grep -qiE 'duplicate session|session exists'; then
        return 3
      fi
      printf '%s\n' "$err" >&2
      return 1
    }
    printf '%s\t%s\n' "$short_name" "$session_name"
    return 0
  fi

  local n=1
  local deadline=$((SECONDS + 5))
  while :; do
    if [ "$SECONDS" -ge "$deadline" ] || [ "$n" -gt 999 ]; then
      return 2
    fi
    created_short_name="${type}-${n}"
    created_session="$(tmux_session_from_short_name "$created_short_name")"
    local err
    err="$("${TMUX_CMD[@]}" new-session -d -s "$created_session" -n "$created_short_name" "$cmd" 2>&1)" && {
      printf '%s\t%s\n' "$created_short_name" "$created_session"
      return 0
    }
    if echo "$err" | grep -qiE 'duplicate session|session exists'; then
      n=$((n + 1))
      continue
    fi
    printf '%s\n' "$err" >&2
    return 1
  done
}

session_info_json() {
  local session="$1"
  local short_name="${session#${SESSION_PREFIX}-}"
  local type
  type="$(tmux_session_type "$session")"
  local attached_clients created_epoch last_used_epoch window_name
  attached_clients="$("${TMUX_CMD[@]}" list-clients -t "$session" 2>/dev/null | wc -l | tr -d ' ')"
  read -r _sess created_epoch last_used_epoch < <("${TMUX_CMD[@]}" list-sessions -t "$session" -F '#{session_name} #{session_created} #{session_activity}' 2>/dev/null || true)
  window_name="$("${TMUX_CMD[@]}" list-windows -t "$session" -F '#{window_name}' 2>/dev/null | head -1 || true)"

  if has_python3; then
    python3 - "$PROTOCOL_VERSION" "$(iso_now)" "$session" "$short_name" "$type" "$attached_clients" "$created_epoch" "$last_used_epoch" "$window_name" <<'PY'
import json, sys
from datetime import datetime, timezone

protocol_version = int(sys.argv[1])
now_iso = sys.argv[2]
name = sys.argv[3]
short_name = sys.argv[4]
type_id = sys.argv[5]
attached = sys.argv[6]
created_epoch = sys.argv[7]
last_used_epoch = sys.argv[8]
window_name = sys.argv[9]

def to_iso(epoch_str: str) -> str:
  try:
    epoch = int(epoch_str)
  except Exception:
    return ""
  if epoch <= 0:
    return ""
  return datetime.fromtimestamp(epoch, tz=timezone.utc).isoformat().replace("+00:00", "Z")

attached_int = 0
try:
  attached_int = int(attached)
except Exception:
  attached_int = 0

obj = {
  "name": name,
  "shortName": short_name,
  "type": type_id,
  "tmuxSession": name,
  "attachedClients": attached_int,
  "created": to_iso(created_epoch),
  "lastUsed": to_iso(last_used_epoch),
  "windowName": window_name,
}

print(json.dumps(obj, ensure_ascii=False))
PY
    return 0
  fi

  printf '{"name":"%s","shortName":"%s","type":"%s","tmuxSession":"%s","attachedClients":%s,"created":"%s","lastUsed":"%s","windowName":"%s"}' \
    "$(json_escape_bash "$session")" \
    "$(json_escape_bash "$short_name")" \
    "$(json_escape_bash "$type")" \
    "$(json_escape_bash "$session")" \
    "${attached_clients:-0}" \
    "$(json_escape_bash "$(epoch_to_iso_fallback "$created_epoch")")" \
    "$(json_escape_bash "$(epoch_to_iso_fallback "$last_used_epoch")")" \
    "$(json_escape_bash "$window_name")"
}

cmd_new_json() {
  local type=""
  local short_name=""

  shift || true
  while [ $# -gt 0 ]; do
    case "$1" in
      --type)
        type="${2:-}"
        shift 2
        ;;
      --name)
        short_name="${2:-}"
        shift 2
        ;;
      --json)
        shift 1
        ;;
      --help|-h)
        json_error "E_INVALID_ARGS" "用法: ai new --json --type <typeId> [--name <shortName>]"
        return 1
        ;;
      *)
        json_error "E_INVALID_ARGS" "未知参数: $1" "用法: ai new --json --type <typeId> [--name <shortName>]"
        return 1
        ;;
    esac
  done

  if [ -z "$type" ]; then
    json_error "E_INVALID_ARGS" "缺少 --type" "用法: ai new --json --type <typeId> [--name <shortName>]"
    return 1
  fi

  if [ ! -f "$types_yaml" ]; then
    json_error "E_CONFIG_NOT_FOUND" "types 配置不存在" "未找到: $types_yaml"
    return 1
  fi

  if ! grep -q "^  $type:" "$types_yaml"; then
    json_error "E_TYPE_NOT_FOUND" "未知类型: $type" "检查 $types_yaml 的 types 定义"
    return 1
  fi

  if [ -n "$short_name" ]; then
    if ! is_valid_short_name "$short_name"; then
      json_error "E_INVALID_SHORT_NAME" "非法 shortName: $short_name" "仅允许 [a-zA-Z0-9_-]+"
      return 1
    fi
    if [ "${SESSION_PREFIX}-${short_name}" = "$MASTER_SESSION" ]; then
      json_error "E_INVALID_SHORT_NAME" "shortName 'master' 为保留字" "请换一个名称"
      return 1
    fi
  fi

  local cmd
  cmd="$(get_cmd_for_type "$type")"
  if [ -z "$cmd" ]; then
    json_error "E_TYPE_NOT_FOUND" "在配置中未找到 type 的 cmd" "type=$type; file=$types_yaml"
    return 1
  fi

  local created_line
  local err_rc=0
  created_line="$(tmux_new_session_atomic "$type" "$cmd" "$short_name" 2> >(cat >&2))" || err_rc=$?
  if [ "$err_rc" -eq 2 ]; then
    json_error "E_TIMEOUT" "创建超时" "请稍后重试"
    return 1
  fi
  if [ "$err_rc" -eq 3 ]; then
    json_error "E_NAME_TAKEN" "名称已存在: $short_name" "换一个名字或留空自动编号"
    return 1
  fi
  if [ "$err_rc" -ne 0 ] || [ -z "$created_line" ]; then
    json_error "E_TMUX_FAILED" "创建 session 失败" "请打开 TMUX_AI_DEBUG=1 查看 stderr"
    return 1
  fi

  local created_short created_session
  created_short="$(printf '%s' "$created_line" | awk -F'\t' '{print $1}')"
  created_session="$(printf '%s' "$created_line" | awk -F'\t' '{print $2}')"

  "${TMUX_CMD[@]}" set-option -t "$created_session" -q "$TMUX_AI_TYPE_OPTION" "$type" 2>/dev/null || true

  local session_json
  session_json="$(session_info_json "$created_session")"

  if has_python3; then
    python3 - "$PROTOCOL_VERSION" "$session_json" <<'PY'
import json, sys

protocol_version = int(sys.argv[1])
session = json.loads(sys.argv[2])
obj = {"ok": True, "protocolVersion": protocol_version, "session": session}
print(json.dumps(obj, ensure_ascii=False))
PY
    return 0
  fi

  printf '{"ok":true,"protocolVersion":%d,"session":%s}\n' "$PROTOCOL_VERSION" "$session_json"
}

cmd_attach_json() {
  shift || true # attach
  shift || true # --json
  local short_name="${1:-}"
  if [ -z "$short_name" ]; then
    json_error "E_INVALID_ARGS" "用法: ai attach --json <shortName>"
    return 1
  fi
  if ! is_valid_short_name "$short_name"; then
    json_error "E_INVALID_SHORT_NAME" "非法 shortName: $short_name" "仅允许 [a-zA-Z0-9_-]+"
    return 1
  fi

  local session
  session="$(tmux_session_from_short_name "$short_name")"
  if ! "${TMUX_CMD[@]}" has-session -t "$session" 2>/dev/null; then
    json_error "E_SESSION_NOT_FOUND" "session 不存在: $short_name" "先创建：ai new --json --type <typeId>"
    return 1
  fi

  local session_json
  session_json="$(session_info_json "$session")"

  if has_python3; then
    python3 - "$PROTOCOL_VERSION" "$tmux_conf" "$TMUX_SOCKET" "${TMUX_TMPDIR:-}" "$session" "$session_json" <<'PY'
import json, sys

protocol_version = int(sys.argv[1])
tmux_conf = sys.argv[2]
socket = sys.argv[3]
tmux_tmpdir = sys.argv[4]
session = sys.argv[5]
session_obj = json.loads(sys.argv[6])

argv = ["tmux", "-f", tmux_conf, "-L", socket, "attach", "-t", session]
if tmux_tmpdir:
  argv = ["env", f"TMUX_TMPDIR={tmux_tmpdir}"] + argv
obj = {"ok": True, "protocolVersion": protocol_version, "argv": argv, "session": session_obj}
print(json.dumps(obj, ensure_ascii=False))
PY
    return 0
  fi

  local conf_esc socket_esc session_esc tmpdir_esc
  conf_esc="$(json_escape_bash "$tmux_conf")"
  socket_esc="$(json_escape_bash "$TMUX_SOCKET")"
  tmpdir_esc="$(json_escape_bash "${TMUX_TMPDIR:-}")"
  session_esc="$(json_escape_bash "$session")"
  if [ -n "${TMUX_TMPDIR:-}" ]; then
    printf '{"ok":true,"protocolVersion":%d,"argv":["env","TMUX_TMPDIR=%s","tmux","-f","%s","-L","%s","attach","-t","%s"],"session":%s}\n' \
      "$PROTOCOL_VERSION" "$tmpdir_esc" "$conf_esc" "$socket_esc" "$session_esc" "$session_json"
  else
    printf '{"ok":true,"protocolVersion":%d,"argv":["tmux","-f","%s","-L","%s","attach","-t","%s"],"session":%s}\n' \
      "$PROTOCOL_VERSION" "$conf_esc" "$socket_esc" "$session_esc" "$session_json"
  fi
}

cmd_rename_json() {
  shift || true # rename
  shift || true # --json
  local old_short="${1:-}"
  local new_short="${2:-}"

  if [ -z "$old_short" ] || [ -z "$new_short" ]; then
    json_error "E_INVALID_ARGS" "用法: ai rename --json <oldShortName> <newShortName>"
    return 1
  fi
  if ! is_valid_short_name "$old_short"; then
    json_error "E_INVALID_SHORT_NAME" "非法 shortName: $old_short" "仅允许 [a-zA-Z0-9_-]+"
    return 1
  fi
  if ! is_valid_short_name "$new_short"; then
    json_error "E_INVALID_SHORT_NAME" "非法 shortName: $new_short" "仅允许 [a-zA-Z0-9_-]+"
    return 1
  fi
  if [ "${SESSION_PREFIX}-${new_short}" = "$MASTER_SESSION" ]; then
    json_error "E_INVALID_SHORT_NAME" "shortName 'master' 为保留字" "请换一个名称"
    return 1
  fi

  local old_session new_session
  old_session="$(tmux_session_from_short_name "$old_short")"
  new_session="$(tmux_session_from_short_name "$new_short")"

  if ! "${TMUX_CMD[@]}" has-session -t "$old_session" 2>/dev/null; then
    json_error "E_SESSION_NOT_FOUND" "session 不存在: $old_short"
    return 1
  fi
  if "${TMUX_CMD[@]}" has-session -t "$new_session" 2>/dev/null; then
    json_error "E_NAME_TAKEN" "名称已存在: $new_short"
    return 1
  fi

  local err
  err="$("${TMUX_CMD[@]}" rename-session -t "$old_session" "$new_session" 2>&1)" || {
    printf '%s\n' "$err" >&2
    json_error "E_TMUX_FAILED" "rename 失败" "设置 TMUX_AI_DEBUG=1 查看 stderr"
    return 1
  }

  local win_count
  win_count="$("${TMUX_CMD[@]}" list-windows -t "$new_session" -F '#{window_index}' 2>/dev/null | wc -l | tr -d ' ')"
  if [ "$win_count" = "1" ]; then
    local first_idx
    first_idx="$("${TMUX_CMD[@]}" list-windows -t "$new_session" -F '#{window_index}' 2>/dev/null | head -1)"
    "${TMUX_CMD[@]}" rename-window -t "${new_session}:${first_idx}" "$new_short" 2>/dev/null || true
  fi

  local session_json
  session_json="$(session_info_json "$new_session")"

  if has_python3; then
    python3 - "$PROTOCOL_VERSION" "$session_json" <<'PY'
import json, sys

protocol_version = int(sys.argv[1])
session = json.loads(sys.argv[2])
obj = {"ok": True, "protocolVersion": protocol_version, "session": session}
print(json.dumps(obj, ensure_ascii=False))
PY
    return 0
  fi

  printf '{"ok":true,"protocolVersion":%d,"session":%s}\n' "$PROTOCOL_VERSION" "$session_json"
}

cmd_kill_json() {
  shift || true # kill
  shift || true # --json
  local short_name="${1:-}"
  if [ -z "$short_name" ]; then
    json_error "E_INVALID_ARGS" "用法: ai kill --json <shortName>"
    return 1
  fi
  if ! is_valid_short_name "$short_name"; then
    json_error "E_INVALID_SHORT_NAME" "非法 shortName: $short_name" "仅允许 [a-zA-Z0-9_-]+"
    return 1
  fi

  local session
  session="$(tmux_session_from_short_name "$short_name")"
  if ! "${TMUX_CMD[@]}" has-session -t "$session" 2>/dev/null; then
    json_error "E_SESSION_NOT_FOUND" "session 不存在: $short_name"
    return 1
  fi

  local err
  err="$("${TMUX_CMD[@]}" kill-session -t "$session" 2>&1)" || {
    printf '%s\n' "$err" >&2
    json_error "E_TMUX_FAILED" "kill 失败" "设置 TMUX_AI_DEBUG=1 查看 stderr"
    return 1
  }

  json_ok_simple
}

cmd_detach_all_json() {
  shift || true # detach-all
  shift || true # --json
  local short_name="${1:-}"
  if [ -z "$short_name" ]; then
    json_error "E_INVALID_ARGS" "用法: ai detach-all --json <shortName>"
    return 1
  fi
  if ! is_valid_short_name "$short_name"; then
    json_error "E_INVALID_SHORT_NAME" "非法 shortName: $short_name" "仅允许 [a-zA-Z0-9_-]+"
    return 1
  fi

  local session
  session="$(tmux_session_from_short_name "$short_name")"
  if ! "${TMUX_CMD[@]}" has-session -t "$session" 2>/dev/null; then
    json_error "E_SESSION_NOT_FOUND" "session 不存在: $short_name"
    return 1
  fi

  local err
  err="$("${TMUX_CMD[@]}" detach-client -s "$session" 2>&1)" || {
    printf '%s\n' "$err" >&2
    json_error "E_TMUX_FAILED" "detach-all 失败" "设置 TMUX_AI_DEBUG=1 查看 stderr"
    return 1
  }

  json_ok_simple
}

# 模糊匹配：根据前缀找实例
fuzzy_match() {
  local pattern="$1"
  local sessions
  sessions="$(get_instance_sessions)"

  if [ -z "$sessions" ]; then
    return 1
  fi

  # pattern 已经是完整 session 名
  if [[ "$pattern" =~ ^${SESSION_PREFIX}- ]]; then
    if echo "$sessions" | grep -Fxq "$pattern"; then
      echo "$pattern"
      return 0
    fi

    while read -r s; do
      [ -z "$s" ] && continue
      if [ "${s:0:${#pattern}}" = "$pattern" ]; then
        echo "$s"
        return 0
      fi
    done <<<"$sessions"

    return 1
  fi

  # 精确匹配
  local candidate="${SESSION_PREFIX}-${pattern}"
  if echo "$sessions" | grep -Fxq "$candidate"; then
    echo "$candidate"
    return 0
  fi

  # 前缀匹配
  local prefix="${SESSION_PREFIX}-${pattern}"
  while read -r s; do
    [ -z "$s" ] && continue
    if [ "${s:0:${#prefix}}" = "$prefix" ]; then
      echo "$s"
      return 0
    fi
  done <<<"$sessions"

  return 1
}

# 按编号获取实例
get_session_by_index() {
  local idx="$1"
  local sessions
  sessions="$(get_instance_sessions)"
  echo "$sessions" | sed -n "${idx}p"
}

# 列出所有实例（带编号）
list_sessions() {
  local sessions
  sessions="$(get_instance_sessions)"

  if [ -z "$sessions" ]; then
    echo "没有实例"
    return
  fi

  echo "现有实例:"
  local idx=1
  while read -r session; do
    [ -z "$session" ] && continue
    local window
    window="$("${TMUX_CMD[@]}" list-windows -t "$session" -F '#{window_name}' 2>/dev/null | head -1 || true)"

    if [ -n "$window" ]; then
      printf "  [%d] %s (%s)\n" "$idx" "$session" "$window"
    else
      printf "  [%d] %s\n" "$idx" "$session"
    fi
    idx=$((idx + 1))
  done <<<"$sessions"
}

cmd_new_interactive() {
  local type="${1:-}"
  local short_name="${2:-}"

  if [ -z "$type" ]; then
    echo "用法: ai new <type> [name]  (claude/gemini/codex)" >&2
    exit 1
  fi

  if [ ! -f "$types_yaml" ]; then
    echo "错误: types 配置不存在：$types_yaml" >&2
    exit 1
  fi

  if ! grep -q "^  $type:" "$types_yaml"; then
    echo "错误: 未知类型 '$type'，请检查：$types_yaml" >&2
    exit 1
  fi

  if [ -n "$short_name" ]; then
    if ! is_valid_short_name "$short_name"; then
      echo "错误: name 只能包含字母/数字/_-" >&2
      exit 1
    fi
    if [ "${SESSION_PREFIX}-${short_name}" = "$MASTER_SESSION" ]; then
      echo "错误: name 'master' 为保留字" >&2
      exit 1
    fi
  fi

  local cmd
  cmd="$(get_cmd_for_type "$type")"
  if [ -z "$cmd" ]; then
    echo "错误: 在配置中未找到 type 的 cmd：$type（$types_yaml）" >&2
    exit 1
  fi

  local created_line
  local err_rc=0
  created_line="$(tmux_new_session_atomic "$type" "$cmd" "$short_name" 2> >(cat >&2))" || err_rc=$?
  if [ "$err_rc" -eq 2 ]; then
    echo "错误: 创建超时，请稍后重试" >&2
    exit 1
  fi
  if [ "$err_rc" -eq 3 ]; then
    echo "错误: 名称已存在: $short_name" >&2
    exit 1
  fi
  if [ "$err_rc" -ne 0 ] || [ -z "$created_line" ]; then
    echo "错误: 创建失败（设置 TMUX_AI_DEBUG=1 查看 stderr）" >&2
    exit 1
  fi

  local created_short created_session
  created_short="$(printf '%s' "$created_line" | awk -F'\t' '{print $1}')"
  created_session="$(printf '%s' "$created_line" | awk -F'\t' '{print $2}')"

  "${TMUX_CMD[@]}" set-option -t "$created_session" -q "$TMUX_AI_TYPE_OPTION" "$type" 2>/dev/null || true

  echo "已创建实例: $created_session"
  exec "${TMUX_CMD[@]}" attach -t "$created_session"
}

attach_or_create() {
  local target="${1:-}"
  if [ -z "$target" ]; then
    echo "用法: ai <name|编号|快捷键>   # 如: ai claude-1, ai 1, ai c1" >&2
    exit 1
  fi

  if [[ "$target" =~ ^[0-9]+$ ]]; then
    local selected
    selected="$(get_session_by_index "$target")"
    if [ -n "$selected" ]; then
      exec "${TMUX_CMD[@]}" attach -t "$selected"
    fi
    echo "错误: 无效编号 '$target'" >&2
    exit 1
  fi

  local expanded
  expanded="$(expand_shortcut "$target")"

  local matched
  matched="$(fuzzy_match "$expanded" || true)"
  if [ -n "$matched" ]; then
    exec "${TMUX_CMD[@]}" attach -t "$matched"
  fi

  local short_name="$expanded"
  if [[ "$expanded" =~ ^${SESSION_PREFIX}- ]]; then
    short_name="${expanded#${SESSION_PREFIX}-}"
  fi

  # 兼容 ai-tmux：attach 到 <type>-<n> 若不存在则自动创建
  if [[ "$short_name" =~ ^([A-Za-z0-9_-]+)-([0-9]+)$ ]]; then
    local type="${BASH_REMATCH[1]}"

    if [ -f "$types_yaml" ] && grep -q "^  $type:" "$types_yaml"; then
      local cmd
      cmd="$(get_cmd_for_type "$type")"
      if [ -z "$cmd" ]; then
        echo "错误: 在配置中未找到 type 的 cmd：$type（$types_yaml）" >&2
        exit 1
      fi

      local created_line
      local err_rc=0
      created_line="$(tmux_new_session_atomic "$type" "$cmd" "$short_name" 2> >(cat >&2))" || err_rc=$?
      if [ "$err_rc" -eq 3 ]; then
        exec "${TMUX_CMD[@]}" attach -t "$(tmux_session_from_short_name "$short_name")"
      fi
      if [ "$err_rc" -ne 0 ] || [ -z "$created_line" ]; then
        echo "错误: 创建失败（设置 TMUX_AI_DEBUG=1 查看 stderr）" >&2
        exit 1
      fi

      local created_session
      created_session="$(printf '%s' "$created_line" | awk -F'\t' '{print $2}')"
      "${TMUX_CMD[@]}" set-option -t "$created_session" -q "$TMUX_AI_TYPE_OPTION" "$type" 2>/dev/null || true

      echo "实例 $created_session 不存在，已自动创建..."
      exec "${TMUX_CMD[@]}" attach -t "$created_session"
    fi
  fi

  echo "错误: 未找到实例 '$target'" >&2
  echo "运行 'ai list' 查看所有实例" >&2
  exit 1
}

cmd_master_interactive() {
  local master_session="$MASTER_SESSION"

  if ! "${TMUX_CMD[@]}" has-session -t "$master_session" 2>/dev/null; then
    "${TMUX_CMD[@]}" new-session -d -s "$master_session" -n "master"
  fi

  local has_unlinked="0"
  while read -r _win_id win_linked; do
    [ -z "${win_linked:-}" ] && continue
    if [ "$win_linked" = "0" ]; then
      has_unlinked="1"
      break
    fi
  done < <("${TMUX_CMD[@]}" list-windows -t "$master_session" -F '#{window_id} #{window_linked}' 2>/dev/null || true)

  if [ "$has_unlinked" = "0" ]; then
    "${TMUX_CMD[@]}" new-window -t "$master_session" -n "master"
  fi

  while read -r win_id win_linked; do
    [ -z "${win_id:-}" ] && continue
    if [ "$win_linked" = "1" ]; then
      "${TMUX_CMD[@]}" unlink-window -t "${master_session}:${win_id}" 2>/dev/null || true
    fi
  done < <("${TMUX_CMD[@]}" list-windows -t "$master_session" -F '#{window_id} #{window_linked}' 2>/dev/null || true)

  local sessions
  sessions="$(get_instance_sessions)"

  local index=1
  local linked_count=0
  while read -r session; do
    [ -z "$session" ] && continue
    if "${TMUX_CMD[@]}" link-window -k -s "${session}:1" -t "${master_session}:${index}" 2>/dev/null; then
      index=$((index + 1))
      linked_count=$((linked_count + 1))
    fi
  done <<<"$sessions"

  if [ "$linked_count" -gt 0 ]; then
    while read -r win_id win_linked; do
      [ -z "${win_id:-}" ] && continue
      if [ "$win_linked" = "0" ]; then
        "${TMUX_CMD[@]}" kill-window -t "${master_session}:${win_id}" 2>/dev/null || true
      fi
    done < <("${TMUX_CMD[@]}" list-windows -t "$master_session" -F '#{window_id} #{window_linked}' 2>/dev/null || true)
  fi

  exec "${TMUX_CMD[@]}" attach -t "$master_session"
}

cmd_delete_interactive() {
  local target="${1:-}"
  if [ -z "$target" ]; then
    echo "用法: ai delete <name|编号>  (如: ai delete claude-2 / ai delete 2)" >&2
    exit 1
  fi

  local session=""
  if [[ "$target" =~ ^[0-9]+$ ]]; then
    session="$(get_session_by_index "$target")"
  else
    target="$(expand_shortcut "$target")"
    session="$(fuzzy_match "$target" || true)"
    if [ -z "$session" ]; then
      if [[ "$target" =~ ^${SESSION_PREFIX}- ]]; then
        session="$target"
      else
        session="$(tmux_session_from_short_name "$target")"
      fi
    fi
  fi

  if [ -z "$session" ] || ! "${TMUX_CMD[@]}" has-session -t "$session" 2>/dev/null; then
    echo "错误: 实例 '$target' 不存在" >&2
    exit 1
  fi

  "${TMUX_CMD[@]}" kill-session -t "$session"
  echo "已删除实例: $session"
}

cmd_cleanup_interactive() {
  local sessions
  sessions="$(get_instance_sessions)"

  local all="$sessions"
  if "${TMUX_CMD[@]}" has-session -t "$MASTER_SESSION" 2>/dev/null; then
    all="${all}"$'\n'"$MASTER_SESSION"
  fi

  if [ -z "$all" ]; then
    echo "没有实例需要清理"
    return
  fi

  echo "将删除以下实例:"
  echo "$all"

  local confirm=""
  if [ -t 0 ]; then
    read -r -p "确认? (y/N): " confirm
  else
    confirm=""
  fi

  if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
    echo "$all" | while read -r session; do
      [ -z "$session" ] && continue
      "${TMUX_CMD[@]}" kill-session -t "$session" 2>/dev/null || true
      echo "已删除: $session"
    done
    return 0
  fi

  echo "取消"
}

# 智能切换：不带参数时自动选择实例
smart_attach() {
  local sessions
  sessions="$(get_instance_sessions)"

  if [ -z "$sessions" ]; then
    echo "没有实例，创建 claude-1..."
    cmd_new_interactive claude
  fi

  local count=$(echo "$sessions" | wc -l)
  if [ "$count" -eq 1 ]; then
    local session=$(echo "$sessions" | head -1)
    echo "附加到唯一实例: $session"
    exec "${TMUX_CMD[@]}" attach -t "$session"
  fi

  # 多个实例，显示选择
  list_sessions

  if [ -t 0 ]; then
    echo -n "选择编号 (或快捷键 c1/g1/x1，直接回车创建新 claude): "
    read -r choice
    if [ -z "$choice" ]; then
      cmd_new_interactive claude
    fi

    # 数字选择
    if [[ "$choice" =~ ^[0-9]+$ ]]; then
      local selected=$(get_session_by_index "$choice")
      if [ -n "$selected" ]; then
        exec "${TMUX_CMD[@]}" attach -t "$selected"
      fi
    fi

    # 快捷键选择
    local expanded=$(expand_shortcut "$choice")
    local matched=$(fuzzy_match "$expanded" || true)
    if [ -n "$matched" ]; then
      exec "${TMUX_CMD[@]}" attach -t "$matched"
    fi

    echo "无效选择" >&2
    exit 1
  else
    echo ""
    echo "使用: ai <name|编号|快捷键>   # 如: ai claude-1, ai 1, ai c1"
    exit 1
  fi
}

# 重命名实例
rename_session() {
  local old_name="$1"
  local new_name="$2"

  # 展开快捷键
  old_name="$(expand_shortcut "$old_name")"
  new_name="$(expand_shortcut "$new_name")"

  local old_session=""
  if [[ "$old_name" =~ ^[0-9]+$ ]]; then
    old_session="$(get_session_by_index "$old_name")"
  else
    old_session="$(fuzzy_match "$old_name" || true)"
  fi

  if [ -z "$old_session" ]; then
    echo "错误: 未找到实例 '$old_name'" >&2
    exit 1
  fi

  # 自动添加前缀
  if [[ ! "$new_name" =~ ^${SESSION_PREFIX}- ]]; then
    new_name="${SESSION_PREFIX}-${new_name}"
  fi

  if ! is_valid_session_name "$new_name"; then
    echo "错误: 新名称只能包含字母/数字/._-，且必须以字母或数字开头" >&2
    exit 1
  fi

  if [ "$new_name" = "$MASTER_SESSION" ]; then
    echo "错误: '$new_name' 为保留名称" >&2
    exit 1
  fi

  # 检查新名称是否已存在
  if "${TMUX_CMD[@]}" has-session -t "$new_name" 2>/dev/null; then
    echo "错误: 实例 '$new_name' 已存在" >&2
    exit 1
  fi

  # 重命名
  "${TMUX_CMD[@]}" rename-session -t "$old_session" "$new_name"

  # 单窗口实例：同步窗口名为新 id（方便 master 视图与列表展示）
  local win_count
  win_count="$("${TMUX_CMD[@]}" list-windows -t "$new_name" -F '#{window_index}' 2>/dev/null | wc -l | tr -d ' ')"
  if [ "$win_count" = "1" ]; then
    local first_idx
    first_idx="$("${TMUX_CMD[@]}" list-windows -t "$new_name" -F '#{window_index}' 2>/dev/null | head -1)"
    "${TMUX_CMD[@]}" rename-window -t "${new_name}:${first_idx}" "${new_name#${SESSION_PREFIX}-}" 2>/dev/null || true
  fi

  echo "已重命名: ${old_session#${SESSION_PREFIX}-} → ${new_name#${SESSION_PREFIX}-}"
}

# 主命令分发
case "${1:-help}" in
  ls|list)
    if [ "${2:-}" = "--json" ]; then
      cmd_list_json
      exit $?
    fi
    list_sessions
    ;;
  new)
    for arg in "$@"; do
      if [ "$arg" = "--json" ]; then
        cmd_new_json "$@"
        exit $?
      fi
    done
    cmd_new_interactive "${2:-}" "${3:-}"
    ;;
  attach)
    if [ "${2:-}" = "--json" ]; then
      cmd_attach_json "$@"
      exit $?
    fi
    attach_or_create "${2:-}"
    ;;
  kill)
    if [ "${2:-}" = "--json" ]; then
      cmd_kill_json "$@"
      exit $?
    fi
    cmd_delete_interactive "${2:-}"
    ;;
  detach-all)
    if [ "${2:-}" = "--json" ]; then
      cmd_detach_all_json "$@"
      exit $?
    fi
    echo "用法: ai detach-all --json <shortName>" >&2
    exit 1
    ;;
  master)
    cmd_master_interactive
    ;;
  rename|mv)
    if [ "${2:-}" = "--json" ]; then
      cmd_rename_json "$@"
      exit $?
    fi
    if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
      echo "用法: ai rename <old> <new>  或  ai mv <old> <new>" >&2
      echo "示例: ai rename c1 c3     # claude-1 → claude-3" >&2
      echo "      ai rename c1 work   # claude-1 → ai-work" >&2
      exit 1
    fi
    rename_session "$2" "$3"
    ;;
  delete|rm|del)
    cmd_delete_interactive "${2:-}"
    ;;
  cleanup)
    cmd_cleanup_interactive
    ;;
  help|--help|-h)
    cat <<'HELP'
ai - AI tmux session 简短管理命令 v0.0.1

用法:
  ai                    智能选择实例（菜单）
  ai list               列出所有实例（带编号）
  ai list --json         以 JSON 输出 sessions/types（供 VS Code 扩展）
  ai new <type> [name]  创建新实例 (claude/gemini/codex)
  ai new --json --type <typeId> [--name <shortName>]  创建新实例（JSON）
  ai attach --json <shortName>  获取 attach argv（JSON）
  ai rename --json <oldShortName> <newShortName>  重命名（JSON）
  ai kill --json <shortName>  删除实例（JSON）
  ai detach-all --json <shortName>  断开所有 clients（JSON）

快速切换:
  ai claude-1           完整名称
  ai c1                 快捷键 (c=claude, g=gemini, x=codex)
  ai 1                  编号切换（第1个实例）

重命名:
  ai rename <old> <new> 重命名实例
  ai mv c1 c3           claude-1 → claude-3

管理:
  ai master             统一视图模式
  ai delete <name|编号> 删除实例
  ai cleanup            清理所有实例

快捷键映射:
  c1 → claude-1    g1 → gemini-1    x1 → codex-1
  c2 → claude-2    g2 → gemini-2    x2 → codex-2

配置:
  TMUX_AI_CONFIG 环境变量可指定配置目录（默认: ~/.config/tmux-ai）

示例:
  ai                    # 菜单选择
  ai c1                 # 快捷进入 claude-1
  ai 2                  # 编号进入第2个实例
  ai work               # 进入 ai-work（自定义名称）
  ai new claude work    # 创建 ai-work
  ai rename c1 work     # 重命名为 ai-work
  ai list               # 查看所有

文档: https://github.com/your-username/tmux-ai-cli
HELP
    ;;
  "")
    smart_attach
    ;;
  *)
    attach_or_create "$1"
    ;;
esac
